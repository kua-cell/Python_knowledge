# Python 标准库是什么

Python 语言提供了非常庞大的组件，本文的呈现方式为罗列，为你描述和提供常用组件，以及其核心用途。

这些标准库很多都是用 C 语言进行编写，所以执行效率都非常高。

常用标准库清单如下

    sys
    os
    math
    random
    pikle
    subprocess
    queue
    StringIO
    logging
    json
    time
    datetime
    re
    csv
    threading
    asyncio

怎么用
sys

sys 模块用于处理 Python 解析器相关的变量和方法，例如获取命令行参数，退出 Python 程序，获取输入输出相关内容。
os

os 模块，即系统模块，它提供了用于访问操作系统相关的功能，os 模块中的接口有些是特定平台使用的，所以要特殊记忆。

主要功能

    系统相关 API
    目录和文件操作
    执行命令
    管理进程

math

math 模块提供了对 C 标准定义的数学函数，但是这些函数不适用于复数，常用的有 ceil()，floor()，abs()，sin() 等方法。

一些常量，例如 math.pi ，出场率极高。
random

random 模块用于生成伪随机数，伪随机数是由随机种子根据算法计算而来，处理一些简单的逻辑随机数，可以直接使用该模块。
pikle

该模块是 Python 中用于数据持久化的模块，可以持久化各种类型的数据，该模块持久化的数据无法直接读取，并且仅能在 Python 代码中进行读取。
subprocess

该模块主要用于进程操作，你可以使用它执行操作系统级别的命令，学习的时候优先掌握 run() 方法，使用其创建子进程，操作系统命令。
queue

队列模块，用于将数据存放在内存中，并进行数据交换。
StringIO

StringIO 模块，可以将字符串存储在内存中，然后像操作文件一样操作
logging

日志模块。
json

操作 JSON 格式数据的模块。
time 和 datetime

时间模块，time 模块目前只支持到 2038 年前，如果超过这个时间，使用 datetime 模块。
re

正则表达式处理模块。
csv

csv 文件操作模块。
threading

多线程模块，非常重要和高级的模块。
asyncio

异步 I/O 模块。
time、datetime 时间模块，calendar 日历模块 实战举例

接下来我们介绍一些典型的标准库，从日期时间库开始。

在 Python 中是没有原生数据类型支持时间的，日期与时间的操作需要借助三个模块，分别是 time、datetime、calendar。

time 模块可以操作 C 语言库中的时间相关函数，时钟时间与处理器运行时间都可以获取。
datetime 模块提供了日期与时间的高级接口。
calendar 模块为通用日历相关函数，用于创建数周、数月、数年的周期性事件。

在学习之前，还有一些术语要补充一下，这些术语你当成惯例即可。这里在 Python 官方文档中也有相关说明，不过信息比较多，橡皮擦为你摘录必须知道的一部分。

epoch（纪元） 是时间开始的点，其值取决于平台。
对于 Unix， epoch（纪元） 是 1970年1月1日00:00:00（UTC）。要找出给定平台上的 epoch ，请使用 time.gmtime(0) 进行查看，例如橡皮擦电脑显示：

time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)

术语 纪元秒数 是指自 epoch （纪元）时间点以来经过的总秒数，通常不包括闰秒。 在所有符合 POSIX 标准的平台上，闰秒都不会记录在总秒数中。

程序员中常把 纪元秒数 称为 时间戳。
get_clock_info 函数

该函数获取时钟的基本信息，得到的值因不同系统存在差异，函数原型比较简单：

time.get_clock_info(name)

其中 name 可以取下述值：

    monotonic：time.monotonic()
    perf_counter： time.perf_counter()
    process_time： time.process_time()
    thread_time： time.thread_time()
    time： time.time()

该函数的返回值具有以下属性：

    adjustable ： 返回 True 或者 False。如果时钟可以自动更改（例如通过 NTP 守护程序）或由系统管理员手动更改，则为 True ，否则为 False ;
    implementation ： 用于获取时钟值的基础 C 函数的名称，就是调用底层 C 的函数；
    monotonic ：如果时钟不能倒退，则为 True ，否则为 False；
    resolution ： 以秒为单位的时钟分辨率（ float ）。

import time

available_clocks = [
    ('clock', time.clock),
    ('monotonic', time.monotonic),
    ('perf_counter', time.perf_counter),
    ('process_time', time.process_time),
    ('time', time.time),
]

for clock_name, func in available_clocks:
    print('''
    {name}:
        adjustable    : {info.adjustable}
        implementation: {info.implementation}
        monotonic     : {info.monotonic}
        resolution    : {info.resolution}
        current       : {current}
    '''.format(
        name=clock_name,
        info=time.get_clock_info(clock_name),
        current=func()))

运行结果如下图所示。
滚雪球学 Python 之怎么玩转时间和日期库
上图显示橡皮擦的计算机在 clock 与 perf_counter 中，调用底层 C 函数是一致的。
获取时间戳

在 Python 中通过 time.time() 函数获取纪元秒数，它可以把从 epoch 开始之后的秒数以浮点数格式返回。

import time
print(time.time())

# 输出结果 1615257195.558105

时间戳大量用于计算时间相关程序，属于必须掌握内容。
获取可读时间

时间戳主要用于时间上的方便计算，对于人们阅读是比较难理解的，如果希望获取可读时间，使用 ctime() 函数获取。

import time
print(time.ctime())

# 输出内容：Tue Mar  9 10:35:51 2021

如何将时间戳转换为可读时间，使用 localtime 函数即可。

localtime = time.localtime(time.time())
print("本地时间为 :", localtime)

输出结果为 <class 'time.struct_time'> 类型数据，后文将对其进行格式化操作：

本地时间为 : time.struct_time(tm_year=2021, tm_mon=3, tm_mday=9, tm_hour=10, tm_min=37, tm_sec=27, tm_wday=1, tm_yday=68, tm_isdst=0)

上述代码中的时间戳最小值是 0，最大值由于 Python 环境和操作系统决定，我本地 64 位操作系统进行测试的时候，得到的数据如下：

import time

localtime = time.localtime(0)
print("时间为 :", localtime)
# 时间为 : time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)
localtime = time.localtime(32536799999)
print("时间为 :", localtime)
# 时间为 : time.struct_time(tm_year=3001, tm_mon=1, tm_mday=19, tm_hour=15, tm_min=59, tm_sec=59, tm_wday=0, tm_yday=19, tm_isdst=0)
localtime = time.localtime(99999999999)
print("时间为 :", localtime)
# OSError: [Errno 22] Invalid argument
print(type(localtime))

单调时间 monotonic time

monotonic time 从系统启动开始计时，从 0 开始单调递增。

操作系统的时间可能不是从 0 开始，而且会因为时间出错而回调。

该函数原型如下，不需要任何参数，返回一个浮点数，表示小数秒内的单调时钟的值：

time.monotonic()

测试代码如下：

print("单调时间",time.monotonic())
# 输出：单调时间 12279.244

处理器时钟时间

time() 函数返回的是纪元秒数（时间戳）， clock() 函数返回的是处理器时钟时间。
该函数函数的返回值：

    在第一次调用的时候，返回的是程序运行的实际时间；
    在第二次之后的调用，返回的是自第一次调用后到这次调用的时间间隔。

需要注意的是 Python 3.8 已移除 clock() 函数，用 time.perf_counter() 或 time.process_time() 方法替代。

t0 = time.clock()
# 运行一段代码
print(time.clock() - t0, "程序运行时间")

我使用的 Python 版本较高，提示异常如下：

time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead t0 = time.clock()

性能计数器 time.perf_counter

perf_counter() 函数的 epoch （纪元）是未定义的。一般使用该函数都是为了比较和计算，不是为了用作绝对时间，该点需要注意下。

该函数用于测量较短持续时间的具有最高有效精度的时钟，包括睡眠状态消耗的时间，使用两次调用才会有效。

测试代码如下：

t0 = time.perf_counter()
# 运行一段代码
for i in range(100000):
    pass
print("程序运行时间", time.perf_counter() - t0)

与其类似的函数有 perf_counter_ns()、process_time()、process_time_ns()，具体可以查询手册进行学习，先掌握 perf_counter() 函数即可。
时间组件

上文已经涉及了时间组件相关的知识，通过 localtime 得到的 struct_time 类型的数据。

这里涉及到的函数有 gmtime() 返回 UTC 中的当前时间，localtime() 返回当前时区对应的时间，mktime() 接收 struce_time 类型数据并将其转换成浮点型数值，即时间戳。

print("*"*10)
print(time.gmtime())
print("*"*10)
print(time.localtime())

print("*"*10)
print(time.mktime(time.localtime()))

struct_time 类型包含的内容

上述代码返回的数据格式为：

time.struct_time(tm_year=2021, tm_mon=3, tm_mday=9, tm_hour=12, tm_min=50, tm_sec=35, tm_wday=1, tm_yday=68, tm_isdst=0)

其中各值可以根据英文含义进行理解 ：tm_year 年份（range[1,12]），tm_mon 月份（range[1,12]），tm_mday 天数（range[1,31]），tm_hour 天数（range[0,23]），tm_min 分钟 （range[0,59]）， tm_sec 秒数 （range[0,61]）， tm_wday 星期 （range[0,6]，0 是星期日）， tm_yday 一年中的一天（range[1,366] ），tm_isdst 在夏令时生效时设置为 1，而在夏令时不生效时设置为 0，值-1 表示这是未知的。
解析和格式化时间

strptime() 和 strftime() 函数可以使时间值在 struct_time 表示和字符串表示之间相互转换。

对于 strftime 函数，其中的参数参考官方即可。

x = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
print(x)

滚雪球学 Python 之怎么玩转时间和日期库
这里的学习，没有什么难度大的点，孰能生巧的知识。

strptime 函数的应用

x = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
print(x)
# 方向操作，字符串格式化成 time.struct_time
struct_time = time.strptime(x, "%Y-%m-%d %H:%M:%S")
print(struct_time)

需要记忆的就是 strftime 与 strptime 函数只有中间的字符不同，一个是 f ，另一个是 p。
datetime 模块

该模块比 time 模块高级了很多，并且对 time 模块进行了封装，提供的功能更加强大了。

在 datetime 模块中，Python 提供了 5 个主要的对象类，分别如下：

    datetime：允许同时操作时间和日期；
    date：只操作日期；
    time：只操作时间；
    timedelta：用于操作日期以及测量时间跨度；
    tzinfo：处理时区。

date 类

优先展示部分该类的属性和方法，都是记忆层面的知识。

    min、max：date 对象能表示的最大、最小日期；
    resolution：date 对象表示日期的最小单位，返回天；
    today()：返回表示当前本地日期的 date 对象；
    fromtimestamp(timestamp)：根据时间戳，返回一个 date 对象。

测试代码如下：

from datetime import date
import time
print('date.min:', date.min)
print('date.max:', date.max)
print('date.resolution:', date.resolution)
print('date.today():', date.today())
print('date.fromtimestamp():', date.fromtimestamp(time.time()))

输出结果：

date.min: 0001-01-01
date.max: 9999-12-31
date.resolution: 1 day, 0:00:00
date.today(): 2021-03-09
date.fromtimestamp(): 2021-03-09

date 对象的属性和方法

通过下述代码创建一个 date 对象：

d = date(year=2021,month=3,day=9)
print(d)

该对象具备下述属性和方法：

    d.year：返回年；
    d.month：返回月；
    d.day：返回日；
    d.weekday()：返回 weekday，如果是星期一，返回 0；如果是星期 2，返回 1，以此类推；
    d.isoweekday()：返回 weekday，如果是星期一，返回 1；如果是星期 2，返回 2，以此类推；
    d.isocalendar()：返回格式如(year, wk num, wk day)；
    d.isoformat()：返回格式如’YYYY-MM-DD’的字符串；
    d.strftime(fmt)：自定义格式化字符串，与 time 模块中的 strftime 类似。

time 类

time 类定义的类属性：

    min、max：time 类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)；
    resolution：时间的最小单位，这里是 1 微秒；

通过其构造函数可以创建一个 time 对象。

t = time(hour=20, minute=20, second=40)
print(t)

time 类提供的实例方法和属性：

    t.hour、t.minute、t.second、t.microsecond：时、分、秒、微秒；
    t.tzinfo：时区信息；
    t.isoformat()：返回型如”HH:MM:SS”格式的字符串时间表示；
    t.strftime(fmt)：返回自定义格式化字符串。

datetime 类

该类是 date 类与 time 类的结合体，很多属性和方法前文已经介绍，再补充一些比较常用的属性和方法。

获取当前的日期与时间：

from datetime import datetime
dt = datetime.now()
print(dt)

获取时间戳：

dt = datetime.now()
# 使用 datetime 的内置函数 timestamp()
stamp = datetime.timestamp(dt)
print(stamp)

timedelta 类

通过 timedelta 函数返回一个 timedelta 时间间隔对象，该函数没有必填参数，如果写入一个整数就是间隔多少天的的意思。

# 间隔 10 天
timedelta(10)
# 跨度为1 周
timedelta(weeks=1)

两个时间间隔对象可以彼此之间相加或相减，返回的仍是一个时间间隔对象。
一个 datetime 对象如果减去一个时间间隔对象，那么返回的对应减去之后的 datetime 对象，然后两个 datetime 对象如果相减，返回的是一个时间间隔对象。

更多关于 datetime 类使用的知识，可以参考 官方手册。
calendar 模块（日历）

此模块的函数都是日历相关的，例如打印某月的字符月历。

calendar 模块定义了 Calendar 类，它封装了值的计算， 例如给定月份或年份中周的日期。通过 TextCalendar 和 HTMLCalendar 类可以生成预格式化的输出。

基本代码：

import calendar

c = calendar.TextCalendar(calendar.SUNDAY)
c.prmonth(2021, 3)

上述代码，默认是从周日开始的，输出结果：

     March 2021
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31

random 随机函数模块
seed 与 random 函数

seed 函数初始化一个随机种子，默认是当前系统时间。
random 函数 生成一个 [0.0,1.0) 之间的随机小数 。

具体代码如下：

import random

random.seed(10)

x = random.random()
print(x)

其中需要说明的是 random.seed 函数， 通过 seed 函数 可以每次生成相同的随机数，例如下述代码：

import random

random.seed(10)
x = random.random()
print(x)

random.seed(10)
y = random.random()
print(y)

在不同的代码上获取到的值是不同的，但是 x 与 y 是相同的。

0.5714025946899135
0.5714025946899135

getstate() 和 setstate(state)

getstate 函数用来记录随机数生成器的状态，setstate 函数用来将生成器恢复到上次记录的状态。

# 记录生成器的状态
state_tuple = random.getstate()
for i in range(4):
    print(random.random())
print("*"*10)
# 传入参数后恢复之前状态
random.setstate(state_tuple)
for j in range(4):
    print(random.random())

输出的随机数两次一致。

0.10043296140791758
0.6183668665504062
0.6964328590693109
0.6702494141830372
**********
0.10043296140791758
0.6183668665504062
0.6964328590693109
0.6702494141830372

randint 和 randrange

randint 生成一个 [x,y] 区间之内的整数。
randrange 生成一个 [m,n) 区间之内以 k 为步长的随机整数。

测试代码如下：

x = random.randint(1,10)
print(x)

y = random.randrange(1,10,2)
print(y)

这两个函数比较简单，randint 函数原型如下：

random.randint(start,stop)

参数 start 表示最小值，参数 stop 表示最大值，两头都是闭区间，也就是 start 和 stop 都能被获取到。

randrange 函数原型如下：

random.randrange(start,stop,step)

如果函数调用时只有一个参数，默认是从 0 到该参数值，该函数与 randint 区别在于，函数是左闭右开，最后一个参数是步长。

查阅效果，可以复制下述代码运行：

for i in range(3):
    print("*"*20)
    print(random.randrange(10))
    print(random.randrange(5,10))
    print(random.randrange(5,100,5))

getrandbits(k) 和 choice(seq)

getrandbits 生成一个 k 比特长的随机整数，实际输出的是 k 位二进制数转换成的十进制数。
choice 从序列中随机选择一个元素。

x =  random.getrandbits(5)
print(x)
# 生成的长度是 00000-11111

getrandbits(k) 函数可以简单描述如下：输出一个 [ 0 , 2 k − 1 ] [0,2^k-1] [0,2k−1] 范围内一个随机整数，k 表示的是 2 进制的位数。

choice 就比较简单了，从列表中返回一个随机元素。

import random

my_list = ["a", "b", "c"]

print(random.choice(my_list))

shuffle(seq) 和 sample(pop,k)

shuffle 函数用于将序列中的元素随机排序，并且原序列被修改。
sample 函数用于从序列或者集合中随机选择 k 个选择，原序列不变。

my_list = [1,2,3,4,5,6,7,8,9]
random.shuffle(my_list)

print(my_list)

shuffle 函数只能用于可变序列，不可变序列（如元组）会出现错误。

my_list = ["梦想", "橡皮擦", 1, 2, [3, 4]]
print(my_list)
ls = random.sample(my_list, 4)
print(ls)

uniform(a,b) 、betavariate 和 triangular 函数

uniform 生成一个 [a,b] 之间的随机小数，采用等概率分布。
betavariate 生成一个 [0,1] 之间的随机小数，采用 beta 分布。
triangular 生成一个 [low,high] 之间的随机小数，采用三角分布。

在使用 uniform 时候需要注意，如果 a<b，那么生成一个 b-a 之间的小数。

for i in range(3):
    print(random.uniform(4, 1))

其它分布随机函数

以下都是生成随机数的方法，只是底层核心算法不同。
、、、、、、、。

    expovariate：生成一个 (0,∞) 之间的随机整数，指数分布；
    gammavariate：采用 gamma 分布；
    gauss：采用高斯（正太）分布；
    lognormvariate：对数正太分布；
    normalvariate：正太分布；
    vonmisesvariate：冯米赛斯分布；
    paretovariate：帕累托分布；
    weibullvariate：韦伯分布。

os 库

在 Python 中 os 库提供了基本的操作系统交互功能，该库下包含大量与文件系统、操作系统相关的函数，通过 dir 函数可以查看。

['DirEntry', 'F_OK', 'MutableMapping', 'O_APPEND', 'O_BINARY', 'O_CREAT', 'O_EXCL', 'O_NOINHERIT', 'O_RANDOM', 'O_RDONLY', 'O_RDWR', 'O_SEQUENTIAL', 'O_SHORT_LIVED', 'O_TEMPORARY', 'O_TEXT', 'O_TRUNC', 'O_WRONLY', 'P_DETACH', 'P_NOWAIT', 'P_NOWAITO', 'P_OVERLAY', 'P_WAIT', 'PathLike', 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'TMP_MAX', 'W_OK', 'X_OK', '_Environ', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_execvpe', '_exists', '_exit', '_fspath', '_get_exports_list', '_putenv', '_unsetenv', '_wrap_close', 'abc', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'close', 'closerange', 'cpu_count', 'curdir', 'defpath', 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fdopen', 'fsdecode', 'fsencode', 'fspath', 'fstat', 'fsync', 'ftruncate', 'get_exec_path', 'get_handle_inheritable', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getenv', 'getlogin', 'getpid', 'getppid', 'isatty', 'kill', 'linesep', 'link', 'listdir', 'lseek', 'lstat', 'makedirs', 'mkdir', 'name', 'open', 'pardir', 'path', 'pathsep', 'pipe', 'popen', 'putenv', 'read', 'readlink', 'remove', 'removedirs', 'rename', 'renames', 'replace', 'rmdir', 'scandir', 'sep', 'set_handle_inheritable', 'set_inheritable', 'spawnl', 'spawnle', 'spawnv', 'spawnve', 'st', 'startfile', 'stat', 'stat_result', 'statvfs_result', 'strerror', 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids', 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sys', 'system', 'terminal_size', 'times', 'times_result', 'truncate', 'umask', 'uname_result', 'unlink', 'urandom', 'utime', 'waitpid', 'walk', 'write']

内容太多，通过截图查阅比较清晰。

os 库、 sys 库、getopt 库 与 filecmp 库，万字长文带你搞定四大库
这些函数主要分为几类。

    路径操作：os.path 子库，处理文件路径及信息；
    进程管理：启动系统中其它程序；
    环境参数：获得系统软硬件信息等环境参数。

os 库路径操作

os.path 在 os 库中用于提供操作和处理文件路径相关函数，常见的函数清单如下：
函数名	简介
os.path.abspath(path)	返回绝对路径
os.path.normpath(path)	规范 path 字符串形式
os.path.realpath(path)	返回 path 的真实路径
os.path.dirname(path)	返回文件路径
os.path.basename(path)	返回文件名
os.path.join(path1[, path2[, …]])	把目录和文件名合成一个路径
os.path.exists(path)	如果路径 path 存在，返回 True；如果路径 path 不存在，返回 False。
os.path.isfile(path)	判断路径是否为文件
os.path.isdir(path)	判断路径是否为目录
os.path.getatime(path)	返回最近访问时间（浮点型秒数）
os.path.getmtime(path)	返回最近文件修改时间
os.path.getsize(path)	返回文件大小，如果文件不存在就返回错误

以上函数的使用过程比较容易理解，导入模块之后，调用即可。

模块导入使用下述方式：

import os.path
# import os.path as op
variate = os.path.abspath(__file__)
print(variate)

函数的参数都是 path，在传入的时候，特备要注意原生字符串的应用，还有要区分绝对路径和相对路径的问题。

由于 path 相关的库比较简单，每个内容都尝试一遍即可掌握，其它内容可以在 手册 进行学习。
os 库进程管理

该内容主要用于在 Python 中执行程序或命令 Command，函数原型为：

os.system(command)

例如，在 Python 中唤醒画板程序。

os.system("c:\windows/system32/mspaint.exe")

除了 system 函数以外，还有一个 os.exec 函数族相关知识。具体可以查看下述函数的用法：

    os.execl(path, arg0, arg1, …)
    os.execle(path, arg0, arg1, …, env)
    os.execlp(file, arg0, arg1, …)
    os.execlpe(file, arg0, arg1, …, env)
    os.execv(path, args)
    os.execve(path, args, env)
    os.execvp(file, args)
    os.execvpe(file, args, env)

这些函数都将执行一个新程序，以替换当前进程。
os 库运行环境相关参数

环境参数顾名思义就是改变系统环境信息，或者理解为 Python 运行环境相关信息。

通过下述属性，可以获取环境变量：

os.environ

如果希望获取操作系统类型，使用 os.name，目前只有 3 个值：分别是 posix , nt , java

函数部分，主要掌握的函数有：

    os.chdir(path)：修改当前程序操作的路径；
    os.getcwd()：返回程序运行的路径；
    os.getlogin()：获取当前登录用户名称；
    os.cpu_count()：获得当前系统的 CPU 数量；
    os.urandom(n)：返回一个有 n 个 byte 长的一个随机字符串，用于加密运算。

sys 库

该库主要维护一些与 Python 解释器相关的参数变量和方法。
常见属性如下

sys.argv
获取命令行参数列表，第一个元素是程序本身。

使用方式如下：

import sys
print(sys.argv)

接下来通过控制台运行 python 程序时，需要携带参数，下述代码 312.py 是 python 文件名，1、2、3 是后缀的参数。

python 312.py 1 2 3

执行程序之后，得到的结果为：

['312.py', '1', '2', '3']

第一个是文件名，后面依次是传递进来的参数。

sys.platform
获取 Python 运行平台的信息，结果比 os.name 要准确。

sys.path
获取 PYTHONPATH 环境变量的值，一般用作模块搜索路径。

import sys
print(sys.path)

sys.modules
以字典的形式获取所有当前 Python 环境中已经导入的模块。

sys.stdin，sys.stdout，sys.stderr
sys.stdin , sys.stdout ，sys.stderr 变量包含与标准 I/O 流对应的流对象。


import sys

标准输出, sys.stdout.write() 的形式就是 print() 不加'\n' 的形式。
sys.stdout.write("hello")
sys.stdout.write("world")

"""sys.stdin 标准输入，等价于 input。

sys.ps1 和 sys.ps2
指定解释器的首要和次要提示符。仅当解释器处于交互模式时，它们才有定义。具体测试如下：

PS > python
Python 3.7.3 (v3.7.3:xxxxxx, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps1 = "***"
***print("hello")
hello

常见方法如下

**sys.exit(n) **
退出 Python 程序，exit(0)表示正常退出。
当参数非 0 时，会引发一个 SystemExit 异常，可以在程序中捕获该异常。参数也可以称为状态码。
"""
sys.getdefaultencoding()     # 获取系统当前编码，有的博客中写默认为 ascii，但是我本地默认为 utf-8；
sys.setdefaultencoding()     # 设置系统的默认编码；
sys.getfilesystemencoding()  # 获取文件系统使用编码方式，默认 utf-8。

sys.getrecursionlimit()、sys.setrecursionlimit()
获取 Python 的最大递归数目和设置最大递归数目

sys.getswitchinterval()、sys.setswitchinterval(interval)
获取和设置解释器的线程切换间隔时间（单位为秒）